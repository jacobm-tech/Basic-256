# 15puzzle_new.kbs - slide the tiles to get them back in order
# this is a conversion from the old gosub to the new function/subroutines
# 2012-10-06 j.m.reneau

fastgraphics

global board, nx, ny, zx, zy, bw, xw, yw

nx = 4 # number of boxes in a row
ny = 4 # number of boxes in a column
dim board(nx, ny)
zx = 0 # position of the empty tile
zy = 0

bw = 5 # border width
xw = (graphwidth - ((nx+1)*bw)) / nx # calculate size of a box
yw = (graphheight - ((ny+1)*bw)) / ny

print "slide puzzle"
print "click on tile to slide.  try to get all tiles in order."

print "shufflle..."
call  initialboard
call shuffle
call drawboard

clickclear
moves = 0

print "click tile to move"
do
   # wait for click
   while clickb = 0
      pause .01
   end while
   cx = int(clickx/(xw+bw))
   if cx >= nx then cx = nx-1
   cy = int(clicky/(yw+bw))
   if cy >= ny then cy = ny-1
   clickclear
   # if a real click then make move
   if (zx = cx) or (zy = cy) then
      call makemove(cx, cy)
      moves = moves + 1
      call drawboard
   end if
until isdone()

print "Game Over - You solved it in "+ moves +"."

end

subroutine shuffle()
   #for t = 1 to nx * ny * 10
   for t = 1 to 100
      x = zx
      y = zy
      r = int(rand*4)
      if r = 0 and x > 0 then x = x - 1
      if r = 1 and x < nx-1 then x = x + 1
      if r = 2 and y > 0 then y = y - 1
      if r = 3 and y < ny-1 then y = y + 1
      if x<>zx or y<> zy then
         board[zx, zy] = board[x, y]
         board[x, y] = 0
         zx = x
         zy = y
      end if
      call drawboard
      pause .01
   next t
end subroutine

subroutine makemove(x,y)
   # shift cells
   if zx<>x then
      # row shift
      if x>zx then
         dx = 1
         dy = 0
      else
         dx = -1
         dy = 0
      end if
   else
      # column shift
      if y>zy then
         dx = 0
         dy = 1
      else
         dx = 0
         dy = -1
      end if
   end if
   # do shift
   while zx <> x or zy <> y
      board[zx, zy] = board[zx+dx, zy+dy]
      board[zx+dx, zy+dy] = 0
      zx = zx + dx
      zy = zy + dy
   end while
end subroutine

subroutine initialboard()
   # setup the initial board array
   for x= 0 to nx-1
      for y = 0 to ny-1
         board[x, y] = (y*nx+x+1)
      next y
   next x
   zx = nx-1
   zy = ny-1
   board[zx, zy] = 0
end subroutine

subroutine drawboard()
   font "Tahoma", 120/nx, 100
   clg
   color black
   rect 0, 0, graphwidth, graphheight
   for y = 0 to ny-1
      for x = 0 to nx-1
         b =  board[x, y]
         color white
         rect (x+1)*bw+x*xw, (y+1)*bw+y*yw ,xw, yw
         
         if b <> 0 then
            if zx = x or zy = y then
               color blue
            else
               color darkblue
            endif
            text (x+1)*bw+x*xw, (y+1)*bw+y*yw, b
         end if
      next x
   next y
   refresh
end subroutine

function isdone()
   # return 1 if we have solved the puzzle
   for x= 0 to nx-1
      for y = 0 to ny-1
         if board[x, y] <>  (y*nx+x+1)  and (x <> zx or y <> zy) then
            isdone = false
            return
         end if
      next y
   next x
   isdone = true
end function